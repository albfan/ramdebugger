<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>


  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">

  
  <title>Understanding TkTreeCtrl</title>
</head>


<body>


<h1>Understanding TkTreeCtrl</h1>


<h2>Table of Contents</h2>


<ul>


  <li><a href="#Loading_the_treectrl_package">Loading
the treectrl package</a></li>


  <li><a href="#Creating_a_new_treectrl_window">Creating
a new treectrl window</a></li>


  <li><a href="#Adding_columns">Adding columns</a></li>


  <li><a href="#Adding_items">Adding items</a></li>


  <li><a href="#Modifying_the_hierarchy_of_items">Modifying
the hierarchy of items</a></li>


  <li><a href="#Specifying_the_appearance_of_items">Specifying
the appearance of items</a></li>


  <li><a href="#The_style_layout_options">The style
layout options</a></li>


  <li><a href="#How_items_are_arranged_on_screen">How
items are arranged on screen</a></li>
  <li><a href="#How_the_width_of_items_is_determined">How the width of items is determined</a></li>


  <li><a href="#Adding_items_on_demand">Adding items
on demand</a></li>


</ul>


<h3><a name="Loading_the_treectrl_package"></a>Loading
the treectrl package</h3>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td><span style="font-weight: bold;">package
require</span>
treectrl</td>


    </tr>


  
  </tbody>
</table>


<h3><a name="Creating_a_new_treectrl_window"></a>Creating
a new treectrl window</h3>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>set T [<span style="font-weight: bold;">treectrl&nbsp;</span>
.myTreeCtrl <span style="font-style: italic;">?option
value ...?</span>]</td>


    </tr>


  
  </tbody>
</table>


<h3><a name="Adding_columns"></a>Adding columns</h3>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>set columnID [$T <span style="font-weight: bold;">column
create</span> <span style="font-style: italic;">?option
value ...?</span>]</td>


    </tr>


  
  </tbody>
</table>


<br>


The [$T column create] command not only creates a new column but also
adds that column to the list of columns maintained by the treectrl
window. The new column appears at the end of the list of columns.<br>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note</span> &nbsp;There
is
a special column called the <span style="font-weight: bold;">tail</span>
column that is created when the treectrl window is created. The tail
column always appears to the right of any other columns created by the
[$T column create] command. It is not possible to delete the tail
column.</td>


    </tr>


  
  </tbody>
</table>


<h3><a name="Adding_items"></a>Adding items</h3>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>set itemID [$T <span style="font-weight: bold;">item
create</span> <span style="font-style: italic;">?option
value ...?</span>]</td>


    </tr>


  
  </tbody>
</table>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note&nbsp;</span> The <span style="font-weight: bold;">root</span>
item is created when a treectrl window is created. It is not possible
to delete the root item.</td>


    </tr>


  
  </tbody>
</table>


<h3><a name="Modifying_the_hierarchy_of_items"></a>Modifying
the hierarchy of items</h3>


There are 4 commands which set the parent-child relationship
between one item and another. You only need to use one of these
commands to add an item to another item's list of children.<br>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(204, 204, 204);">$T
      <span style="font-weight: bold;">item firstchild</span>
$parent $child<br>


$T <span style="font-weight: bold;">item lastchild</span>
$parent
$child<br>


$T <span style="font-weight: bold;">item nextsibling</span>
$item
$sibling<br>


$T <span style="font-weight: bold;">item prevsibling</span>
$item
$sibling</td>


    </tr>


  
  </tbody>
</table>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note&nbsp;</span> An
item
can only be a child of a single parent. Also, you cannot make the root
item a child of another item.</td>


    </tr>


  
  </tbody>
</table>


<br>


There is a 5th command which removes an item from its parent's list of
children.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">item
remove</span> $item</td>


    </tr>


  
  </tbody>
</table>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note</span> &nbsp;An
item
without a parent is known as an <span style="font-style: italic;">orphan</span>
and is never
displayed in the treectrl window. You can get a list of orphan items
using the command [$T orphans].</td>


    </tr>


  
  </tbody>
</table>


<h3><a name="Specifying_the_appearance_of_items"></a>Specifying
the appearance of items</h3>


Up to this point you have learned how to create a new treectrl window,
add columns, add&nbsp;items, and set the parent-child relationship
between those items. But what do those items look like on screen? How
are the images, text, fonts, colors etc specified for each item? In
fact there is no default appearance for items provided by a treectrl
window. The good news is you have a great deal of control over the
appearance of items so you do not have to make due with what the
treectrl developer thought was best. The bad news is you have to do a
bit more work (i.e., typing) than you might like.<br>


<br>


Lets start with a basic question:&nbsp;what types of graphical
information&nbsp;can be displayed by an item? The answer is there
are 6
types of graphical things that can be displayed,
namely&nbsp;bitmaps,
3D borders, images,&nbsp;rectangles,&nbsp;strings of text, and
other Tk
windows. There can be any number&nbsp;of these 6 graphical things
displayed in each column of each item. Each graphical thing has its own
set of options to control its appearance, such as the font used for
strings of text, or the color used to fill a rectangle. The graphical
<span style="font-style: italic;">things</span> I
have been telling you
about are called <span style="font-weight: bold;">elements</span>.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">element
create</span>
myElement1 image <span style="font-style: italic;">?option
value...? </span>$T <span style="font-weight: bold;">element
create</span>
myElement2 text <span style="font-style: italic;">?option
value...?</span></td>


    </tr>


  
  </tbody>
</table>


<br>


So now you know there are bitmap elements, 3D border elements,
image elements, rectangle elements, text elements and window elements.
When you create a treectrl window you need to decide which of these
elements to use to display your data. You also need to decide how to
arrange these elements on screen. So how do you group elements together
to arrange them on screen? The answer is you use a <span style="font-weight: bold;">style</span>. A <span style="font-weight: bold;">style</span> is a thing
that maintains
layout information for a list of elements.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">style
create</span>
myStyle1 <span style="font-style: italic;">?option
value...?</span></td>


    </tr>


  
  </tbody>
</table>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note&nbsp;</span> There
is
no limit on the number of styles or elements that may be
created in a treectrl window.</td>


    </tr>


  
  </tbody>
</table>


<br>


After you create a new style, you must specify a list of one or more
elements that the style will arrange on screen. <br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">style
elements </span>myStyle1
[list myElement1 myElement2]</td>


    </tr>


  
  </tbody>
</table>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note</span>&nbsp; An
element can be used only once by a particular style. However, the same
element can be used by more than one style at a time.&nbsp;</td>


    </tr>


  
  </tbody>
</table>


<br>


Your new style is no use on its own, you must now assign the style to
the column of an item. One, and only one style may be specified for
each column of each item.
So as far as graphical appearance goes, you can think of an item as a
list of styles, one style per column. If no style is specified for a
column of an item, then nothing is displayed there (except for the
background color).<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">item
style set</span>
$itemID $columnID myStyle1<span style="font-style: italic;"></span></td>


    </tr>


  
  </tbody>
</table>


<br>


Now you may be asking yourself, do I
need to create a brand new style for every column of every item? The
answer is no. When you create a style, it is defined for the whole
treectrl window. You can assign that style to the particular columns of
whatever items you choose. The same style can be assigned to different
columns of the same item, and to the columns of any number of different
items.<br>


<br>


If you understand what I've been telling you up to this point, you will
now be wondering how it is that different items can have different text
or images displayed if those items are sharing the same style. It's
true that after you assign a particular style to more than one item
those
items will all display exactly the same information, as determined by
the element options and&nbsp;layout information for those elements.
What you need to do is configure some of the element options in a
particular column of a particular item.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">item
element configure</span>
$itemID $columnID myElement2 <span style="font-style: italic;">?option
value...?</span></td>


    </tr>


  
  </tbody>
</table>


<br>


The [$T item element configure] command is how you would set the text
for each item, for example. The whole point of styles is to avoid
assigning colors, fonts etc for every single item, which would be slow
and use a lot of memory. You could have an element that displays a
folder image, and another element that displays a file image, and use
those elements in many different items, thereby avoiding assigning the
same image over and over again.<br>


<h3><a name="The_style_layout_options"></a>The
style layout options</h3>


You know how to create elements and styles, and how to specify a
list of elements for a style. I mentioned that "A <span style="font-weight: bold;">style</span> is a thing
that maintains
layout information for a list of elements." So after you specify a
style's list of elements, you must then tell the style how to arrange
its elements on screen.<br>


<br>


<div style="text-align: center;">
<div style="text-align: left;">
<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>$T <span style="font-weight: bold;">style
layout </span>myStyle1
myElement1 <span style="font-style: italic;">?option
value...?</span></td>


    </tr>


  
  </tbody>
</table>


<br>


The [$T style layout] command is like a geometry manager for
elements, similar to the Tk <span style="font-weight: bold;">grid</span>,
<span style="font-weight: bold;">pack</span> and <span style="font-weight: bold;">place</span> commands. With
the help of an
example I will show you how some of the style layout options work.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>package require treectrl<br>


treectrl .t<br>


pack .t<br>


      <br>


set column [.t column create -text hello -width 150 -itembackground
linen]<br>


      <br>


.t element create elemGray rect -fill gray -width 20 -height 10<br>


.t element create elemBlue rect -fill blue -width 20 -height 30<br>


.t element create elemGreen rect -fill green -width 20 -height 20<br>


      <br>


.t style create style1<br>


.t style elements style1 {elemGray elemBlue elemGreen}<br>


      <br>


.t item style set root $column style1</td>


    </tr>


  
  </tbody>
</table>


<div style="text-align: left; margin-left: 40px;"><img src="understanding/under001.png" alt="" style="width: 206px; height: 206px;">
</div>


<br>


You can see that by default the elements are arranged from left to
right in the same order given to the [.t style elements] command. Each
element is given only as much space as it requests, in this case 20
pixels each. Also notice that the height of the root item is equal to
the height of the tallest element (the blue box).<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemBlue -padx 4 -pady 2<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under002.png">
</div>


<br>


An element has 0 or more pixels of padding on each side. The padding
pushes the element away from other elements and from the edges of the
item. Notice that the root item is now 4 pixels taller because of the
-pady padding.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGreen -expand n</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under003.png">
</div>


<br>


The -expand option tells the style to give extra space to the -padx and
-pady options. I told the style to give all the extra vertical space to
the north or top side of the green box. As as result the green box is
pushed to the bottom of the root item.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGreen -expand ns</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under004.png">
</div>


<br>


Now half of the extra space is given to the top of the green box and
half to the bottom. As a result, the green box is centered vertically
inside the item.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -iexpand y</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under005.png">
</div>


<br>


This new option -iexpand tells the style to give extra space to the <span style="font-style: italic;">inside</span> of the gray
box instead of
to the outside like -expand does.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -iexpand xy</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under006.png">
</div>


<br>


Now the gray box has been given all the extra horizontal space of the
root item.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -sticky ""<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under007.png">
</div>


<br>


The -sticky option controls how an element is stretched and positioned
within the space given to it. The gray box is still given extra
"inside" space from the -iexpand option, but it isn't stretching to
fill that space.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -sticky w<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under008.png">
</div>


<br>


Now the gray box is sticking to the west or left side of
its&nbsp;inside space.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -sticky ws<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under009.png">
</div>


<br>


Now the gray box is also sticking to the south or bottom side of
its&nbsp;inside space.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -sticky wnes<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under006.png">
</div>


<br>


Now the default behavior is restored, and the gray box sticks to all
sides of its&nbsp;inside space.<br>


<br>


<table style="text-align: left; width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td style="background-color: rgb(255, 255, 204);"><span style="font-weight: bold;">Note</span> &nbsp;Some
elements like text and images are not stretched by the -sticky option.</td>


    </tr>


  
  </tbody>
</table>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -detach yes<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under010.png">
</div>


<br>


The -detach option tells the style to place an element by itself,
without affecting the position of any other elements. The gray box
completely fills the root item because of the -iexpand and -sticky
options. The blue and green&nbsp;boxes are now shifted to the left
since the gray box is not taking up space on the left. The gray box
appears behind the blue and green boxes because it is first in the list
of elements. Elements are drawn from first to last in the style's list
of elements.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -union elemGreen<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px; text-align: left;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under011.png">
</div>


<br>


What happened to the gray box? The answer is the gray box is now
exactly the same size as the green box. The -union option lets you wrap
an element around one or more other elements.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -ipadx 4 -ipady 4<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under012.png">
</div>


<br>


You can see the gray box now because I added some&nbsp;padding to
the <span style="font-style: italic;">inside</span>
of the it.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -iexpand n<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under013.png">
</div>


<br>


Now the style is giving extra vertical space to the inside top of the
gray box. The position of the green box is unaffected by this extra
padding.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t style layout style1 elemGray -iexpand ns<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/under014.png">
</div>


<br>


The gray box is now stretched to the height of the root item.<br>


<h3><a name="How_items_are_arranged_on_screen"></a>How
items are arranged on screen</h3>


We've looked at how a style arranges its elements. Now we are going to
look at how a treectrl window arranges its items. The next example
creates a treectrl window with 20 items. Each item has a text element
surrounded by a border element.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>package require treectrl<br>


treectrl .t -showheader no -showroot no -width 250<br>


pack .t<br>


      <br>


set columnID [.t column create]<br>


      <br>


.t element create elemBorder border -background #ece9d8 -filled yes
-relief solid -thickness 1<br>


.t element create elemText text<br>


      <br>


.t style create style1<br>


.t style elements style1 {elemBorder elemText}<br>


.t style layout style1 elemBorder -union&nbsp;elemText -ipadx 4
-ipady 4<br>


.t style layout style1 elemText<br>


      <br>


for {set i 1} {$i &lt;= 20} {incr i} {<br>


&nbsp;&nbsp;&nbsp; set itemID [.t item create]<br>


&nbsp;&nbsp;&nbsp; .t item style set $itemID $columnID
style1<br>


&nbsp;&nbsp;&nbsp; .t item element configure $itemID
$columnID elemText
-text "Item $i"<br>


&nbsp;&nbsp;&nbsp; .t item lastchild root $itemID<br>


}<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 256px; height: 206px;" alt="" src="understanding/itemlay001.png">
</div>


<br>


Here you can see the default behavior, which is to arrange the 20 items
from top to bottom.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -orient horizontal<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 256px; height: 206px;" alt="" src="understanding/itemlay002.png"></div>


<br>


Here we see the first option that controls item arrangement, the
treectrl's -orient option. Now all the items are arranged from left to
right instead of from top to bottom. If you are displaying a film strip
of images it might be useful to arrange items this way.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -wrap "5 items"<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 256px; height: 206px;" alt="" src="understanding/itemlay003.png">
</div>


<br>


I told the treectrl to put no more than 5 items in a row.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -wrap window </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 256px; height: 206px;" alt="" src="understanding/itemlay004.png">
</div>


<br>


Instead of breaking each row at 5 items, the treectrl puts as many
items in a row that fit into the window.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -width 200<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 206px; height: 206px;" alt="" src="understanding/itemlay005.png">
</div>


<br>


Here I just made the window narrower to demonstrate wrapping.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -width 250 -wrap "200 pixels"<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 256px; height: 206px;" alt="" src="understanding/itemlay006.png">
</div>


<br>


The window is back to its original width of 250 pixels. The -wrap
option now says to break each row at 200 pixels, which is exactly how
wide I made the treectrl in the previous example, so we end up with the
same arrangement of items. You have now seen the 3 different
possibilities for the -wrap option:<br>


<ol>


  <li>-wrap "N items"</li>


  <li>-wrap window</li>


  <li>-wrap "N pixels"</li>


</ol>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -orient vertical -wrap window<br>


      </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 256px; height: 206px;" alt="" src="understanding/itemlay007.png">
</div>


<br>


Wrapping works just as well when items are arranged from top to bottom.<br>


<h3><a name="How_the_width_of_items_is_determined"></a>How the width of items is determined</h3>


When more than one column is visible, every item has the same width no
matter what options you use. When only
one column is visible, the amount of width given to an item depends on
a number of factors. The next example creates a list of 20 items with
only one column. Every item is drawn with a "linen" color background to
show you how much width is actually given to each item. With this
example I will show you how the width of items is affected by various
options.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>package require treectrl<br>


treectrl .t -showheader no -showroot no -width 410 -height 300<br>


pack .t -expand yes -fill both<br>


set columnID [.t column create -itembackground linen]<br>


      <br>


.t element create elemBorder border -background #ece9d8 -filled yes
-relief solid -thickness 1<br>


.t element create elemText text<br>


      <br>


.t style create style1<br>


.t style elements style1 {elemBorder elemText}<br>


.t style layout style1 elemBorder -union {elemText} -ipadx 4 -ipady 4<br>


.t style layout style1 elemText<br>


      <br>


foreach n {5 15 20 10 10 5 15 10 20 15 15 25 10 5 15 5 10 20 15
25}&nbsp; {<br>


&nbsp;&nbsp;&nbsp; set itemID [.t item create]<br>


&nbsp;&nbsp;&nbsp; .t item style set $itemID $columnID
style1<br>


&nbsp;&nbsp;&nbsp; set text [string range
"abcdefghijklmnopqrstuvwxyz"
0 $n]<br>


&nbsp;&nbsp;&nbsp; .t item element configure $itemID
$columnID elemText
-text $text<br>


&nbsp;&nbsp;&nbsp; .t item lastchild root $itemID<br>


}</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay008.png">
</div>


<br>
With top-to-bottom layout, and only one column, and no wrapping, every
item is exactly as wide as the column. The column's width is affected
by the requested width of the items, the requested width of the header
(i.e. the column's bitmap/image/text/arrow), and the column's
-minwidth, -width, -maxwidth, -expand and -squeeze options.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td><span style="font-style: italic;"></span>.t
column configure
$columnID -width 200</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay009.png">
</div>


<br>
When the column has a fixed width, the width given to every item is
equal to that width. In this case the requested width of the items, the
requested width of the header, and the other column options have no
effect on item width.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -wrap "10 items"<br>


      <span style="font-style: italic;"></span></td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay010.png">
</div>


<br>


Now there are 2 vertical groups of items. I call each group a <span style="font-weight: bold;">range </span>of items. The
items are
arranged from top to bottom within each range. Both ranges have
the same width of 200 pixels.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t column configure $columnID -width ""<span style="font-style: italic;"></span></td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay011.png">
</div>


<br>


I cleared the fixed column width. Both ranges have a different width
from the other. Now each range is exactly&nbsp;as wide as the
widest
item in that range.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -itemwidthequal yes<br>


      <span style="font-style: italic;"></span></td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay012.png">
</div>


<br>
The -itemwidthequal&nbsp;option causes all items to have the same
width.
The width of every item is equal to the width of the widest item. The
left range is now exactly as wide as the right range, which was the
widest.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -itemwidthequal no -orient horizontal -wrap window<br>


      <span style="font-style: italic;"></span></td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay013.png">
</div>


<br>


Laying out items left-to-right to demonstrate the next option.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t configure -itemwidthmultiple 100<br>


      <span style="font-style: italic;"></span></td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay014.png">
</div>


<br>


The -itemwidthmultiple&nbsp;option gives every item an even multiple of 100
pixels. The narrower items are 100 pixels wide, while the widest are
200.<br>


<br>
<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td>.t configure -itemwidthmultiple "" -itemwidth 100<br>


      <span style="font-style: italic;"></span></td>
    </tr>
  </tbody>
</table>
<div style="margin-left: 40px;"><img style="width: 416px; height: 306px;" alt="" src="understanding/itemlay015.png">
<br>
</div>
<br>
Here the -itemwidth option gives every item a width of 100 pixels.<br>
<br>
The two tables below summarize how item width is determined. The order of precedence is from top to bottom within each table.<br>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <th style="background-color: rgb(204, 255, 255);">Situation (-orient vertical)</th>
      <th style="background-color: rgb(204, 255, 255);">How an item's width is determined</th>
      <th style="background-color: rgb(204, 255, 255);">Items have equal width?</th>
    </tr>
    <tr>
      <td>More than one column is visible</td>
      <td>sum of the calculated widths of all visible columns</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>-wrap == ""</td>
      <td>column's calculated width</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>-itemwidth &gt; 0</td>
      <td>-itemwidth option</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>column -width != ""</td>
      <td>column's -width option<br>
      <span style="font-style: italic;">Using the column's -width option this way is deprecated. Use the treectrl's -itemwidth option instead.</span></td>
      <td>yes</td>
    </tr>
    <tr>
      <td>-itemwidthequal == true</td>
      <td>width of widest item<br>
round up using -itemwidthmultiple</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>all other cases</td>
      <td>requested width of style, plus indentation if this is the tree column<br>
round up using -itemwidthmultiple</td>
      <td>All items in a range have the same width, but each range may have a different width.</td>
    </tr>
  </tbody>
</table>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <th style="background-color: rgb(204, 255, 255);">Situation (-orient horizontal)</th>
      <th style="background-color: rgb(204, 255, 255);">How an item's width is determined</th>
      <th style="background-color: rgb(204, 255, 255);">Items have equal width?</th>
    </tr>
    <tr>
      <td>More than one column is visible</td>
      <td>sum of the calculated widths of all visible columns</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>-itemwidth &gt; 0</td>
      <td>-itemwidth option</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>column -width != ""</td>
      <td>column's -width option<br>
      <span style="font-style: italic;">Using the column's -width option this way is deprecated. Use the treectrl's -itemwidth option instead.</span></td>
      <td>yes</td>
    </tr>
    <tr>
      <td>-itemwidthequal == true</td>
      <td>width of widest item<br>
round up using -itemwidthmultiple</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>all other cases</td>
      <td>requested width of style, plus indentation if this is the tree column<br>
round up using -itemwidthmultiple</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
<h3><a name="Adding_items_on_demand"></a>Adding
items on demand</h3>
If your items have a parent-child relationship (as opposed to a flat
list where every item is a child of the root item), and if you need to
create many thousands of items, it will be faster to add the items only
when the user attempts to display them. This can be done by using the
&lt;Expand-before&gt; event which is generated before an item
is
expanded.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>package require treectrl<br>


treectrl .t -width 400 -height 300 -showrootbutton yes<br>


pack .t -expand yes -fill both<br>


set columnID [.t column create -text "Column 0"]<br>


.t configure -treecolumn $columnID<br>


      <br>


.t element create elemBorder border -background #ece9d8 -filled yes
-relief solid -thickness 1<br>


.t element create elemText text<br>


      <br>


.t style create style1<br>


.t style elements style1 {elemBorder elemText}<br>


.t style layout style1 elemBorder -union {elemText} -ipadx 4 -ipady 4<br>


.t style layout style1 elemText<br>


      <br>


.t item configure root -button yes<br>


.t item style set root $columnID style1<br>


.t item element configure root $columnID elemText
-text "The root item"<br>


      <br>


for {set i 1} {$i &lt;= 100} {incr i} {<br>


&nbsp;&nbsp;&nbsp; set itemID [.t item create -button yes]<br>


&nbsp; &nbsp; .t item collapse $itemID<br>


&nbsp;&nbsp;&nbsp; .t item style set $itemID $columnID
style1<br>


&nbsp;&nbsp;&nbsp; .t item element configure $itemID
$columnID elemText
-text "Item $itemID"<br>


&nbsp;&nbsp;&nbsp; .t item lastchild root $itemID<br>


} </td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 406px; height: 306px;" alt="" src="understanding/expand001.png">
</div>


<br>


This example creates a treectrl and adds 100 child items to the root
item. Every child has a button to indicate that it has children and may
be expanded. However, none of the items created actually have child
items yet. They will only be added when the user expands an item (by
clicking on the item's button, for example). The next bit of code shows
how that is done.<br>


<br>


<table style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;" border="0" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td>.t notify bind .t &lt;Expand-before&gt; {<br>


&nbsp; &nbsp; AddChildItems %T %I<br>


}<br>


      <br>


proc AddChildItems {tree parent} {<br>


      <br>


&nbsp;&nbsp;&nbsp; if {[$tree item numchildren $parent]
&gt; 0} return<br>


      <br>


&nbsp;&nbsp;&nbsp; set columnID first<br>


      <br>


&nbsp;&nbsp;&nbsp; for {set i 1} {$i &lt;= 100} {incr
i} {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; set
itemID [$tree item create -button yes]<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $tree
item collapse $itemID<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $tree
item style set $itemID $columnID style1<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $tree
item element configure $itemID $columnID elemText -text "Item $itemID"<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $tree
item lastchild $parent $itemID<br>


&nbsp;&nbsp;&nbsp; }<br>


      <br>


&nbsp;&nbsp;&nbsp; return<br>


}</td>


    </tr>


  
  </tbody>
</table>


<div style="margin-left: 40px;"><img style="width: 406px; height: 306px;" alt="" src="understanding/expand002.png">
</div>


<br>


After running the new bit of code item #4 is expanded by clicking its
button.<br>


<br>


<div style="margin-left: 40px;"><img style="width: 406px; height: 306px;" alt="" src="understanding/expand003.png">
</div>


<br>


Now item #106 is expanded. In this example you can open items forever
to reveal new items.
</div>


</div>


</body>
</html>
